<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://mjafar.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mjafar.me/" rel="alternate" type="text/html" /><updated>2020-09-06T03:27:11+00:00</updated><id>https://mjafar.me/feed.xml</id><title type="html">Mohammad Jafar Mashhadi</title><subtitle>My portfolio website I guess?</subtitle><entry><title type="html">MSc thesis: Black-box Behavioral Model Inference for Autopilot Software Systems</title><link href="https://mjafar.me/publications/UCalgary-graduate-thesis.html" rel="alternate" type="text/html" title="MSc thesis: Black-box Behavioral Model Inference for Autopilot Software Systems" /><published>2020-09-01T17:10:00+00:00</published><updated>2020-09-01T17:10:00+00:00</updated><id>https://mjafar.me/publications/UCalgary-graduate-thesis</id><content type="html" xml:base="https://mjafar.me/publications/UCalgary-graduate-thesis.html">&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Inferring behavior model of a running software system is quite useful for several automated software engineering tasks, such as program comprehension, anomaly detection, and testing. Most existing dynamic model inference techniques are white-box, i.e., they require source code to be instrumented to get run-time traces. However, in many systems, instrumenting the entire source code is not possible (e.g., when using black-box third-party libraries) or might be very costly. %One useful scenario for automated black-box behavior inference is in software control units (such as autopilots), where the software system’s reactions over time changes based on the inputs. Run-time state models of such systems are very powerful means for anomaly detection and debugging. 
Unfortunately, most black-box techniques that detect states over time are either univariate, or make assumptions on the data distribution, or have limited power for learning over a long period of past behavior. 
To overcome the above issues, in this thesis, I proposed a hybrid deep neural network that accepts as input a set of time series, one per input/output signal of the system, and applies a set of convolutional and recurrent layers to learn the non-linear correlations between signals and the patterns, over time. 
I have applied this approach on two real UAV autopilot case studies: one from our industry partner, MicroPilot (MP in short), with half a million lines of C code, and one widely used open source solution: Paparazzi. 
I ran more than 1200 system-level tests in total (to generate the input data) and inferred the system’s internal state, over time.
In case of Paparazzi, as it did not include system tests like MP, I created a tool that generates and executes meaningful test scenarios.
Comparison with several traditional time series change point detection techniques showed that this approach improves their performance by up to 102\% in MP’s case and 94\% in Paparazzi’s, in terms of finding state change points, measured by F1 score. I also showed that this state classification algorithm provides on average 90.45\% F1 score for MP and 82.23\% for Paparazzi, which improves traditional classification algorithms by up to 17\% in MP’s case and 20\% in Paparazzi’s.&lt;/p&gt;

&lt;p&gt;In addition, by creating a hyper-parameter tuning pipeline using grid search technique, despite having a way smaller training set in the second case study (7 times smaller compared to the first one), I managed to get a better performance, up to 48\% better, out of the neural network model as measured by 8 metrics.
The tuning performance is compared to using the same hyper-parameters that worked for MP’s case, for Paparazzi.%  As a result, in addition to confirming that the technique is applicable on other software, I.&lt;/p&gt;

&lt;h2 id=&quot;related-projects&quot;&gt;Related Projects&lt;/h2&gt;
&lt;h3 id=&quot;hybrid-net&quot;&gt;Hybrid-net&lt;/h3&gt;
&lt;p&gt;The main repository containing the whole learning pipeline. The code is in Python using Keras on Tensor Flow.
&lt;a href=&quot;https://github.com/sea-lab/hybrid-net&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;paparzzi-tester&quot;&gt;Paparzzi Tester&lt;/h3&gt;
&lt;p&gt;:airplane:️ A fuzz testing tool for generating and performing system tests for Paparazzi auto pilot
&lt;a href=&quot;https://github.com/MJafarMashhadi/pprz_tester&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;paparazzi&quot;&gt;Paparazzi&lt;/h3&gt;
&lt;p&gt;I contributed code to Paparazzi autopilot: a free and open-source hardware and software project for unmanned (air) vehicles.
&lt;a href=&quot;https://github.com/MJafarMashhadi/paparazzi&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;pprzlink&quot;&gt;pprzlink&lt;/h3&gt;
&lt;p&gt;I contributed code and documentation to pprzlink: Message and communication library for the Paparazzi UAV system
&lt;a href=&quot;https://github.com/MJafarMashhadi/pprzlink&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;presentation-slides&quot;&gt;Presentation Slides&lt;/h2&gt;
&lt;p&gt;To be added later when finalized&lt;/p&gt;</content><author><name></name></author><category term="publication" /><category term="publication" /><category term="deep learning" /><category term="software engineering" /><category term="thesis" /><summary type="html">Abstract Inferring behavior model of a running software system is quite useful for several automated software engineering tasks, such as program comprehension, anomaly detection, and testing. Most existing dynamic model inference techniques are white-box, i.e., they require source code to be instrumented to get run-time traces. However, in many systems, instrumenting the entire source code is not possible (e.g., when using black-box third-party libraries) or might be very costly. %One useful scenario for automated black-box behavior inference is in software control units (such as autopilots), where the software system’s reactions over time changes based on the inputs. Run-time state models of such systems are very powerful means for anomaly detection and debugging. Unfortunately, most black-box techniques that detect states over time are either univariate, or make assumptions on the data distribution, or have limited power for learning over a long period of past behavior. To overcome the above issues, in this thesis, I proposed a hybrid deep neural network that accepts as input a set of time series, one per input/output signal of the system, and applies a set of convolutional and recurrent layers to learn the non-linear correlations between signals and the patterns, over time. I have applied this approach on two real UAV autopilot case studies: one from our industry partner, MicroPilot (MP in short), with half a million lines of C code, and one widely used open source solution: Paparazzi. I ran more than 1200 system-level tests in total (to generate the input data) and inferred the system’s internal state, over time. In case of Paparazzi, as it did not include system tests like MP, I created a tool that generates and executes meaningful test scenarios. Comparison with several traditional time series change point detection techniques showed that this approach improves their performance by up to 102\% in MP’s case and 94\% in Paparazzi’s, in terms of finding state change points, measured by F1 score. I also showed that this state classification algorithm provides on average 90.45\% F1 score for MP and 82.23\% for Paparazzi, which improves traditional classification algorithms by up to 17\% in MP’s case and 20\% in Paparazzi’s.</summary></entry><entry><title type="html">Hybrid Deep Neural Networks to Infer State Models of Black-Box Systems</title><link href="https://mjafar.me/publications/ASE-2020-deep-neural-net-autopilot-behvaioural-modeling.html" rel="alternate" type="text/html" title="Hybrid Deep Neural Networks to Infer State Models of Black-Box Systems" /><published>2020-08-22T17:10:00+00:00</published><updated>2020-08-22T17:10:00+00:00</updated><id>https://mjafar.me/publications/ASE-2020-deep-neural-net-autopilot-behvaioural-modeling</id><content type="html" xml:base="https://mjafar.me/publications/ASE-2020-deep-neural-net-autopilot-behvaioural-modeling.html">&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Inferring behavior model of a running software system is quite useful for several automated software engineering tasks
such as program comprehension, anomaly detection, and testing. Most existing dynamic model inference techniques are
white-box, i.e., they require source code to be instrumented to get run-time traces. However, in many systems,
instrumenting the entire source code is not possible (e.g. when using black-box third-party libraries) or might be very
costly. Unfortunately, most black-box techniques that detect states over time are either univariate, or make assumptions
on the data distribution, or have limited power for learning over a long period of past behavior. To overcome the above
issues, in this paper, we propose a hybrid deep neural network that accepts as input a set of time series, one per
input/output signal of the system, and applies a set of convolutional and recurrent layers to learn the non-linear
correlations between signals and the patterns, over time. We have applied our approach on a real UAV auto-pilot solution
from our industry partner with half a million lines of C code. We ran 888 random recent system-level test cases and
inferred states, over time. Our comparison with several traditional time series change point detection techniques showed
that our approach improves their performance by up to 102%, in terms of finding state change points, measured by F1 score.
We also showed that our state classification algorithm provides on average 90.45% F1 score, which improves traditional
classification algorithms by up to 17%.&lt;/p&gt;</content><author><name></name></author><category term="publication" /><category term="publication" /><category term="deep learning" /><category term="software engineering" /><summary type="html">Abstract Inferring behavior model of a running software system is quite useful for several automated software engineering tasks such as program comprehension, anomaly detection, and testing. Most existing dynamic model inference techniques are white-box, i.e., they require source code to be instrumented to get run-time traces. However, in many systems, instrumenting the entire source code is not possible (e.g. when using black-box third-party libraries) or might be very costly. Unfortunately, most black-box techniques that detect states over time are either univariate, or make assumptions on the data distribution, or have limited power for learning over a long period of past behavior. To overcome the above issues, in this paper, we propose a hybrid deep neural network that accepts as input a set of time series, one per input/output signal of the system, and applies a set of convolutional and recurrent layers to learn the non-linear correlations between signals and the patterns, over time. We have applied our approach on a real UAV auto-pilot solution from our industry partner with half a million lines of C code. We ran 888 random recent system-level test cases and inferred states, over time. Our comparison with several traditional time series change point detection techniques showed that our approach improves their performance by up to 102%, in terms of finding state change points, measured by F1 score. We also showed that our state classification algorithm provides on average 90.45% F1 score, which improves traditional classification algorithms by up to 17%.</summary></entry><entry><title type="html">An Empirical Study on Practicality of Specification Mining Algorithms on a Real-world Application</title><link href="https://mjafar.me/publications/ICPC-2019-spec-mining-emperical-study.html" rel="alternate" type="text/html" title="An Empirical Study on Practicality of Specification Mining Algorithms on a Real-world Application" /><published>2019-05-24T17:10:00+00:00</published><updated>2019-05-24T17:10:00+00:00</updated><id>https://mjafar.me/publications/ICPC-2019-spec-mining-emperical-study</id><content type="html" xml:base="https://mjafar.me/publications/ICPC-2019-spec-mining-emperical-study.html">&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Dynamic model inference techniques have been the center of many research projects recently. There are now multiple open 
source implementations of state-of-the-art algorithms, which provide basic abstraction and merging capabilities. Most of 
these tools and algorithms have been developed with one particular application in mind, which is program comprehension.
The output models can abstract away the details of the program and represent the software behaviour in a concise and 
easy to understand form. However, one application context that is less studied is using such inferred models for 
debugging, where the behaviour to abstract is a faulty behaviour (e.g., a set of execution traces including a failed 
test case). We tried to apply some of the existing model inference techniques in a real-world industrial context to 
support program comprehension for debugging. Our initial experiments have shown many limitations both in terms of 
implementation as well as the algorithms. The paper will discuss the root cause of the failures and proposes ideas for 
future improvement.&lt;/p&gt;

&lt;h2 id=&quot;presentation-slides&quot;&gt;Presentation Slides&lt;/h2&gt;
&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/z5hAbZ8HZfihvr&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; 
&lt;/div&gt;</content><author><name></name></author><category term="publication" /><category term="publication" /><category term="software engineering" /><summary type="html">Abstract Dynamic model inference techniques have been the center of many research projects recently. There are now multiple open source implementations of state-of-the-art algorithms, which provide basic abstraction and merging capabilities. Most of these tools and algorithms have been developed with one particular application in mind, which is program comprehension. The output models can abstract away the details of the program and represent the software behaviour in a concise and easy to understand form. However, one application context that is less studied is using such inferred models for debugging, where the behaviour to abstract is a faulty behaviour (e.g., a set of execution traces including a failed test case). We tried to apply some of the existing model inference techniques in a real-world industrial context to support program comprehension for debugging. Our initial experiments have shown many limitations both in terms of implementation as well as the algorithms. The paper will discuss the root cause of the failures and proposes ideas for future improvement.</summary></entry><entry><title type="html">Interactive semi-automated specification mining for debugging: An experience report</title><link href="https://mjafar.me/publications/IST-2019-interactive-debugging.html" rel="alternate" type="text/html" title="Interactive semi-automated specification mining for debugging: An experience report" /><published>2019-04-24T17:10:00+00:00</published><updated>2019-04-24T17:10:00+00:00</updated><id>https://mjafar.me/publications/IST-2019-interactive-debugging</id><content type="html" xml:base="https://mjafar.me/publications/IST-2019-interactive-debugging.html">&lt;p&gt;&lt;strong&gt;Also presented at ASE 2019’s &lt;a href=&quot;https://2019.ase-conferences.org/details/ase-2019-Journal-First-Presentations/13/Interactive-semi-automated-specification-mining-for-debugging-An-experience-report&quot;&gt;journal-first presentations track&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;h3 id=&quot;context&quot;&gt;Context&lt;/h3&gt;
&lt;p&gt;Specification mining techniques are typically used to extract the specification of a software in the absence of 
(up-to-date) specification documents. This is useful for program comprehension, testing, and anomaly detection. However, 
specification mining can also potentially be used for debugging, where a faulty behavior is abstracted to give developers 
a context about the bug and help them locating it.&lt;/p&gt;

&lt;h3 id=&quot;objective&quot;&gt;Objective&lt;/h3&gt;
&lt;p&gt;In this project, we investigate this idea in an industrial setting. We propose a very basic semi-automated specification 
mining approach for debugging and apply that on real reported issues from an AutoPilot software system from our industry 
partner, MicroPilot Inc. The objective is to assess the feasibility and usefulness of the approach in a real-world 
setting.&lt;/p&gt;

&lt;h3 id=&quot;method&quot;&gt;Method&lt;/h3&gt;
&lt;p&gt;The approach is developed as a prototype tool, working on C code, which accept a set of relevant state fields and 
functions, per issue, and generates an extended finite state machine that represents the faulty behavior, abstracted 
with respect to the relevant context (the selected fields and functions).&lt;/p&gt;

&lt;h3 id=&quot;results&quot;&gt;Results&lt;/h3&gt;
&lt;p&gt;We qualitatively evaluate the approach by a set of interviews (including observational studies) with the company’s 
developers on their real-world reported bugs. The results show that (a) our approach is feasible, (b) it can be
automated to some extent, and (c) brings advantages over only using their code-level debugging tools. We also compared 
this approach with traditional fully automated state-merging algorithms and reported several issues when applying those 
techniques on a real-world debugging context.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The main conclusion of this study is that the idea of an “interactive” specification mining rather than a fully 
automated mining tool is NOT impractical and indeed is useful for the debugging use case.&lt;/p&gt;</content><author><name></name></author><category term="publication" /><category term="publication" /><category term="software engineering" /><summary type="html">Also presented at ASE 2019’s journal-first presentations track.</summary></entry></feed>